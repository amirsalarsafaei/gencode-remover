package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/amirsalarsafaei/gencode-remover/remover"
)

const (
	versionArg   = "version"
	recursiveArg = "recursive"
	outputArg    = "output"
	nameArg      = "name"
)

// Project build specific vars
var (
	Tag       string
	Commit    string
	SourceURL string
	GoVersion string

	shouldShowVersion *bool
	isRecursive       *bool
	isOutputOnly      *bool

	generatedName *string
)

func init() {
	isRecursive = flag.Bool(
		recursiveArg,
		false,
		"Apply rules recursively if target is a directory. "+
			"In case of ./... execution will be recursively applied by default. Optional parameter.",
	)

	isOutputOnly = flag.Bool(
		outputArg,
		false,
		"output generated file paths instead of removing it.",
	)

	generatedName = flag.String(
		nameArg,
		"",
		"output generated file paths instead of removing it.",
	)

	if Tag != "" {
		shouldShowVersion = flag.Bool(
			versionArg,
			false,
			"Show version.",
		)
	}
}

func printUsage() {
	if _, err := fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0]); err != nil {
		log.Fatalf("failed to print usage: %s", err)
	}

	flag.PrintDefaults()
}

func printVersion() {
	fmt.Printf(
		"version: %s\nbuild with: %s\ntag: %s\ncommit: %s\nsource: %s\n",
		strings.TrimPrefix(Tag, "v"),
		GoVersion,
		Tag,
		Commit,
		SourceURL,
	)
}

func main() {
	flag.Parse()

	if shouldShowVersion != nil && *shouldShowVersion {
		printVersion()
		return
	}

	originPath := flag.Arg(0)

	if originPath == "" {
		originPath = remover.StandardInput
	}

	if err := validateRequiredParam(originPath); err != nil {
		fmt.Printf("%s\n\n", err)
		printUsage()
		os.Exit(1)
	}

	if _, ok := remover.IsDir(originPath); ok {
		paths, err := remover.NewSourceDir(originPath, *isRecursive, *isOutputOnly, *generatedName).DeleteAutoGeneratedFiles()
		if err != nil {
			log.Fatalf("Failed to fix directory: %+v\n", err)
			return
		}

		for _, path := range paths {
			fmt.Printf("%s ", path)
		}

		return
	}
}

func validateRequiredParam(filePath string) error {
	if filePath == remover.StandardInput {
		stat, _ := os.Stdin.Stat()
		if stat.Mode()&os.ModeNamedPipe == 0 {
			// no data on stdin
			return fmt.Errorf("please give file dir path")
		}
	}
	return nil
}
